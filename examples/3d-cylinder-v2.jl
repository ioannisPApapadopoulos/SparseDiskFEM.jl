using RadialPiecewisePolynomials, PiecewiseOrthogonalPolynomials
using ClassicalOrthogonalPolynomials, LinearAlgebra
using SparseDiskFEM
using Plots, PyPlot

"""
Section 6.4 "Screened Poisson in a 3D cylinder"

Domain is Œ© = {0 ‚â§ r ‚â§ 1} ‚à™ [-1,1] and we are solving, via ADI,
    (-Œî + Œª(r))u(x,y,z) = f(x,y,z)
where the exact solution is not known.
"""
# N‚Çö = 60 on each basis
œÅ, N, Nz = 0.5, 60, 60
points = [0;œÅ;1]
N‚Çï = length(points) - 1

# Disk FEM basis 
Œ¶ = ContinuousZernike(N, points);
Œ® = ZernikeBasis(N, points, 0, 0);

r = range(-1, 1; length=3)
Nz‚Çï = length(r)-1

# Interval FEM basis
P = ContinuousPolynomial{0}(r)
Q = ContinuousPolynomial{1}(r)

Œª(r) = r ‚â§ œÅ ? 1/2 : r^2
function rhs(r,Œ∏,z)
    f1 = r ‚â§ 1/2 ? 2*cos(20*r*sin(Œ∏)) : cos(10*r*cos(Œ∏))
    f2 = z ‚â§ 0 ? 2*cos(20z) : sin(10z)
    f1*f2
end

# RHS in Cartesian coordinates
function rhs_xyz(xy,z)
    x,y = first(xy), last(xy)
    r = sqrt(x^2 + y^2); Œ∏ = atan(y, x)
    rhs(r,Œ∏,z)
end

# Expand in disk basis for each point on the interval grid
ùê≥ = ClassicalOrthogonalPolynomials.grid(P, Nz‚Çï*Nz)
vùê≥ = vec(ùê≥)
X = disk_tensor_transform(Œ®, vùê≥, rhs_xyz, N);

# Expand in interval basis
PP = plan_transform(P, (Block(Nz), sum(1:N)), 1)
# Fs is the list of matrices of expansion coefficients for the RHS.
Fs = [(PP * reshape(X[k]', lastindex(ùê≥)√∑Nz‚Çï, Nz‚Çï, sum(1:N)))' for k in 1:N‚Çï];

# Evaluation points
ùê≥p = range(-1,1,100);

# Evaluate the expansion and check the error
vals_f, rs, Œ∏s, vals_, errs = synthesis_error_transform(Œ®, P, Fs, ùê≥p, rhs_xyz, N, Nz);
maximum(errs)

# Assemble the matrices

# 1D interval basis: stiffness, mass, gram
D = Derivative(axes(Q,1))
pA = ((D*Q)' * (D*Q))
pM = Q' * Q
pG = (Q'*P)[Block.(1:Nz), Block.(1:Nz)];

# 2D disk basis: stiffness, mass, gram
D = Derivative(axes(Œ¶,1));
A = (D*Œ¶)' * (D*Œ¶);
Œõ = Œ¶' * (Œª.(axes(Œ¶,1)).* Œ¶);
M = Œ¶' * Œ¶;
G = Œ¶' * Œ®;

# One day these should be kept sparse
Œõ = Matrix.(Œõ);
M = Matrix.([M...]);
K = Matrix.(A .+  Œõ);
# Apply zero Dirichlet bcs
zero_dirichlet_bcs!(Œ¶, M);
zero_dirichlet_bcs!(Œ¶, Œõ);
zero_dirichlet_bcs!(Œ¶, K);

# Reorganise expansion coefficients from hierarchical ordering to
# Fourier mode ordering
zFs = []
for i in 1:lastindex(ùê≥)
    append!(zFs, [modaltrav_2_list(Œ®, [Fs[k][:,i] for k in 1:N‚Çï])])
end

# ns is the number of basis functions in each Fourier mode
# up to degree n.
ns = getNs(N)

# Truncate 1D interval basis at degree N
tpA = Matrix(pA[Block.(1:N), Block.(1:N)]);
pG = Matrix(pG[Block.(1:N), Block.(1:N)])

# Apply zero BCs
tpA[:,1] .= 0; tpA[1,:] .= 0; tpA[1,1] = 1.0;
tpA[:,Nz‚Çï+1] .= 0; tpA[Nz‚Çï+1,:] .= 0; tpA[Nz‚Çï+1,Nz‚Çï+1] = 1.0;

# Reverse Cholesky
rtpA = tpA[end:-1:1, end:-1:1]
pL = cholesky(Symmetric(rtpA)).L
pL = pL[end:-1:1, end:-1:1]
@assert pL * pL' ‚âà tpA

# Compute spectrum
tpM = Matrix(pM[Block.(1:N), Block.(1:N)])
tpM[:,1] .= 0; tpM[1,:] .= 0; tpM[1,1] = 1.0;
tpM[:,Nz‚Çï+1] .= 0; tpM[Nz‚Çï+1,:] .= 0; tpM[Nz‚Çï+1,Nz‚Çï+1] = 1.0;

B = -(pL \ (pL \ tpM)') # = L‚Åª¬π pM L‚Åª·µÄ
c, d = eigmin(B), eigmax(B)

# Reverse Cholesky
rK = [Ks[end:-1:1, end:-1:1] for Ks in K];
Lb = [cholesky(Symmetric(rKs)).L for rKs in rK];
L = [Lbs[end:-1:1, end:-1:1] for Lbs in Lb];
@assert norm(K .- L.*transpose.(L), Inf) < 1e-10


Us, Js = AbstractMatrix{Float64}[], []
# Run ADI
for i in 1:2N-1
    # Compute spectrum
    B = (L[i] \ (L[i] \ M[i])') # = L‚Åª¬π pM L‚Åª·µÄ
    a, b = eigmin(B), eigmax(B)

    Œ≥ = (c-a)*(d-b)/((c-b)*(d-a))
    append!(Js, [Int(ceil(log(16Œ≥)*log(4/1e-15)/œÄ^2))])

    # weak form for RHS
    fp = zeros(size(G[i],2), size(pG,2))
    for j in 1:N fp[:,j] = zFs[j][i] end
    F_rhs = Matrix(G[i])*fp*pG'  # RHS <f,v>
    F_rhs[N‚Çï, :] .= 0; # disk bcs
    F_rhs[:, 1] .=0; F_rhs[:, Nz‚Çï+1] .= 0; # interval bcs

    X = adi(M[i], -tpM, K[i], tpA, F_rhs, a, b, c, d, tolerance=1e-15)

    U = (pL' \ (pL \ X'))'
    append!(Us, [U])
    
end
vals_u, rs, Œ∏s = synthesis_transform(Œ¶, Q, Us, ùê≥p, N, N)


#### Plotting


iz= 30
zval = round(ùê≥p[iz], digits=2)

### RHS
# Disk slice
SparseDiskFEM.plot(Œ®, Œ∏s, rs, vals_f[iz], ttl=L"f(x,y,%$zval)")
PyPlot.savefig("adi-rhs-2dslice-alternate.png", dpi=500)
# z slice
Œ∏val = round(Œ∏s[1][iz], digits=4)
SparseDiskFEM.zplot(iz, rs, ùê≥p, vals_f, ttl=L"f(x,y,z)", xlabel=L"r", ylabel=L"z", title=L"\theta = %$(Œ∏val)")
PyPlot.savefig("adi-rhs-zslice-alternate.png", dpi=500)
# save for MATLAB 3D Plot.
write_adi_vals(ùê≥p, rs, Œ∏s, vals_f, path="rhs-v2/")

### Solution
SparseDiskFEM.plot(Œ¶, Œ∏s, rs, vals_u[iz], ttl=L"u(x,y,%$zval)")
PyPlot.savefig("adi-sol-2dslice-alternate.png", dpi=500)
Œ∏val = round(Œ∏s[1][iz], digits=4)
SparseDiskFEM.zplot(iz, rs, ùê≥p, vals_u, ttl=L"u(x,y,z)", xlabel=L"r", ylabel=L"z", title=L"\theta = %$(Œ∏val)")
PyPlot.savefig("adi-sol-zslice-alternate.png", dpi=500)
write_adi_vals(ùê≥p, rs, Œ∏s, vals_u, path="sol-v2/")